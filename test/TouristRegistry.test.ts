import ethers  from "hardhat";
import { expect } from "chai";
import { TouristRegistry } from "../typechain-types"; // This import is auto-generated by Hardhat

// `describe` is a container for a group of related tests
describe("TouristRegistry Contract", function () {
  // We define variables here to be accessible in all tests
  let touristRegistry: TouristRegistry;
  let owner;
  let otherAccount;

  // `beforeEach` runs before each test (`it` block)
  // This gives us a fresh contract instance for every test, preventing side-effects
  beforeEach(async function () {
    // Get different accounts from the local Hardhat network
    [owner, otherAccount] = await ethers.getSigners();

    // Deploy a new instance of the TouristRegistry contract
    const touristRegistryFactory = await ethers.getContractFactory("TouristRegistry");
    touristRegistry = await touristRegistryFactory.deploy(owner.address);
    await touristRegistry.waitForDeployment();
  });

  // Test case 1: Check if the contract was deployed correctly
  it("Should deploy successfully and set the right owner", async function () {
    // `expect` is from the Chai library, used for assertions
    expect(await touristRegistry.owner()).to.equal(owner.address);
  });

  // Test case 2: Test the core function `registerTourist`
  it("Should allow the owner to register a new tourist hash", async function () {
    // Generate a sample 32-byte hash
    const dataHash = ethers.encodeBytes32String("sample-data-123");

    // Call the function and check if it emits the correct event
    await expect(touristRegistry.connect(owner).registerTourist(dataHash))
      .to.emit(touristRegistry, "TouristRegistered") // Check for the event name
      .withArgs(1, dataHash, owner.address); // Check for the event arguments

    // Verify the state change
    expect(await touristRegistry.isRegistered(dataHash)).to.be.true;
    expect(await touristRegistry.totalTourists()).to.equal(1);
  });

  // Test case 3: Test a failure condition (registering a duplicate hash)
  it("Should revert if trying to register a duplicate hash", async function () {
    const dataHash = ethers.encodeBytes32String("duplicate-data");

    // Register it the first time (this should work)
    await touristRegistry.connect(owner).registerTourist(dataHash);

    // Try to register the SAME hash again and expect it to fail
    await expect(
      touristRegistry.connect(owner).registerTourist(dataHash)
    ).to.be.revertedWith("Tourist data hash already registered.");
  });

  // Test case 4: Test the `onlyOwner` access control
  it("Should NOT allow a non-owner to register a hash", async function () {
    const dataHash = ethers.encodeBytes32String("some-other-data");

    // Connect as `otherAccount` and try to call the function
    await expect(
      touristRegistry.connect(otherAccount).registerTourist(dataHash)
    ).to.be.revertedWithCustomError(touristRegistry, "OwnableUnauthorizedAccount");
  });
});